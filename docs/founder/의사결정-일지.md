# Decision Log (의사결정 일지)

> **목적**: 프로젝트에서 내린 모든 기술 의사결정을 추적합니다.
> **규칙**: 의사결정이 발생할 때마다 이 파일에 추가합니다. Cowork이 자동 업데이트하되, Gen이 반드시 검토합니다.
> **형식**: 날짜 | 결정 | 선택한 이유 | 포기한 것(trade-off) | 재검토 시점

---

## Day 1-2 (Foundation)

### D-001: Next.js Full-Stack (백엔드 분리 없음)
- **날짜**: W1 D1
- **결정**: Next.js API Routes를 백엔드로 사용. 별도의 Express/NestJS 서버 없음.
- **선택한 이유**: Solo founder — 서버 2개 관리 부담 제거. Next.js 14 App Router가 서버 컴포넌트 + API 라우트를 모두 지원.
- **포기한 것**: 백엔드 독립 배포 불가. 나중에 트래픽 급증 시 API만 따로 스케일링하기 어려움.
- **재검토 시점**: Phase 2에서 대학 20개 이상 온보딩 시.

### D-002: PII 필드 Optional (여권번호, 외국인등록번호)
- **날짜**: W1 D1
- **결정**: passportNumber, arcNumber를 nullable로 설정. 입력 안 해도 학생 등록 가능.
- **선택한 이유**: 파일럿 대학들이 처음부터 모든 데이터를 갖고 있지 않을 수 있음. 점진적 데이터 수집 허용.
- **포기한 것**: FIMS 내보내기 시 빈 필드가 발생할 수 있음 → 미리보기에서 경고로 대응.
- **재검토 시점**: 파일럿 운영 후 실제 데이터 완성도 확인 시.

### D-003: AES-256-GCM 암호화 방식
- **날짜**: W1 D1
- **결정**: PII(여권번호, 외국인등록번호)를 AES-256-GCM으로 암호화 저장.
- **선택한 이유**: 국내 데이터 보호법 + IEQAS 컴플라이언스 요구. GCM 모드는 무결성 검증(tag)도 포함.
- **포기한 것**: DB에서 직접 검색 불가 (암호화된 값은 WHERE 절로 조회 못함). 중복 검사 시 전체 복호화 필요.
- **재검토 시점**: 학생 수 10,000+ 시 중복 검사 성능 이슈 발생 가능.

> **각주: AES-256-GCM이란?**
> 암호화 알고리즘의 한 종류. AES-256 = 키 길이 256비트(매우 강력), GCM = 암호화 + 무결성 검증을 동시에 하는 모드. 즉, 데이터가 암호화될 뿐만 아니라 "누군가 몰래 수정했는지"도 감지 가능.

---

## Day 3 (Traffic Light + Student Management)

### D-004: BLACK 트래픽 라이트 상태 스킵
- **날짜**: W1 D3
- **결정**: 스펙에 정의된 BLACK 상태(90일 무응답 + 출석률 0%)를 Phase 1에서 구현하지 않음. GREEN/YELLOW/RED만 구현.
- **선택한 이유**: BLACK 판정에 필요한 "학생 응답 추적" 인프라가 없음. 알림을 보냈는지, 학생이 응답했는지를 기록하는 시스템이 선행되어야 함.
- **포기한 것**: 장기 무응답 학생(실종 가능성) 자동 감지 불가. 담당자가 수동으로 판단해야 함.
- **재검토 시점**: Phase 2 — 알림 발송 이력 + 학생 응답 추적 시스템 구축 후.

### D-005: 트래픽 라이트 서버사이드 연산
- **날짜**: W1 D3
- **결정**: 트래픽 라이트를 DB에 저장하지 않고, API 호출 시 매번 서버에서 계산.
- **선택한 이유**: TL은 현재 시점 기준으로 계산되어야 함(어제 GREEN이던 학생이 오늘 RED가 될 수 있음). DB에 저장하면 동기화 문제 발생.
- **포기한 것**: 매 요청마다 전체 학생 계산 → 학생 수 많아지면 느려짐. 현재 1,000명 기준 <3초로 OK.
- **재검토 시점**: 학생 수 5,000+ 이상 시 캐싱(Redis) 또는 배치 계산 도입.

> **각주: "서버사이드 연산"이란?**
> DB에 미리 계산해서 저장(=저장형) vs 요청할 때마다 계산(=연산형). 저장형은 빠르지만 최신 상태를 보장하기 어렵고, 연산형은 항상 최신이지만 느릴 수 있음. 여기서는 "항상 최신"이 더 중요해서 연산형 선택.

### D-006: Zustand + fetch (SWR/React Query 미사용)
- **날짜**: W1 D3
- **결정**: 상태 관리에 Zustand만 사용. SWR이나 React Query 같은 데이터 페칭 라이브러리 미도입.
- **선택한 이유**: Phase 1 파일럿 규모(3개 대학, ~1,000명)에서는 캐싱/자동 갱신/중복 요청 방지 등 SWR의 핵심 기능이 불필요. 복잡도만 증가.
- **포기한 것**: 자동 백그라운드 갱신 없음. 탭 전환 후 데이터가 stale할 수 있음. 동일 API 중복 호출 방지 없음.
- **재검토 시점**: Phase 2 — 대학 10개 이상, 동시 접속 사용자 증가 시.

> **각주: SWR/React Query란?**
> 서버에서 데이터를 가져오는 것을 자동화해주는 라이브러리. "캐시에 데이터가 있으면 먼저 보여주고, 백그라운드에서 최신 데이터를 다시 가져와서 교체"하는 전략. 사용자가 많아지면 성능에 큰 차이를 만듦.

### D-007: Day 프롬프트 분할 기준 (5 태스크 초과 시)
- **날짜**: W1 D3
- **결정**: 하나의 Day 프롬프트에 태스크가 5개를 초과하면 Day 3a/3b처럼 분할.
- **선택한 이유**: Claude Code의 컨텍스트 윈도우(대화 기억 용량)에 한계가 있음. 너무 많은 태스크를 한 번에 주면 뒤쪽 태스크의 품질이 떨어짐.
- **포기한 것**: 분할하면 Day 간 맥락 전달이 필요하고, 앞 Day의 버그가 다음 Day로 이월됨.
- **재검토 시점**: 해당 없음 (지속 적용).

---

## Day 4 (Calendar + Import)

### D-008: date-fns 의존성 승인
- **날짜**: W1 D4
- **결정**: 날짜 계산용 라이브러리 date-fns 추가 승인.
- **선택한 이유**: 트래픽 라이트의 "만료일까지 남은 일수" 계산, 캘린더 렌더링 등에 날짜 연산이 반복적으로 필요. 직접 구현하면 타임존/윤년 등 엣지 케이스에서 버그 가능성.
- **포기한 것**: 번들 크기 약간 증가 (~7KB gzipped). 무시할 수 있는 수준.
- **재검토 시점**: 해당 없음.

### D-009: Import에서 AI 컬럼 매핑 대신 규칙 기반 매핑
- **날짜**: W1 D4
- **결정**: Excel 컬럼 자동 매핑을 Claude API 호출 대신 패턴 사전 + 유사도 비교로 구현.
- **선택한 이유**: 매핑은 반복적이고 예측 가능한 작업. "여권번호", "Passport No.", "passport_number" 등 변형을 사전에 등록하면 API 비용 없이 90%+ 매핑 가능.
- **포기한 것**: 완전히 예상 못한 컬럼 헤더(예: 약어)는 매핑 실패 → 수동 매핑으로 대체.
- **재검토 시점**: 파일럿 대학 실제 엑셀 양식 확인 후, 사전 보강 필요 시.

---

## Day 5 (Import Pipeline)

### D-010: 중복 검사 3단계 우선순위
- **날짜**: W2 D5
- **결정**: 임포트 중복 검사를 여권번호(최우선) → 외국인등록번호 → 이름+국적 순서로 수행.
- **선택한 이유**: 여권번호가 가장 고유한 식별자. 하지만 암호화되어 있어 DB 직접 비교 불가 → 전체 복호화 후 비교. ARC는 차선, 이름+국적은 동명이인 가능성 있어 최하위.
- **포기한 것**: 전체 복호화 비용 (1,000명 × 복호화 = 수 초). 10,000명 이상에서 병목 가능.
- **재검토 시점**: Phase 2 — 해시 기반 중복 검사 도입 검토.

> **각주: "해시 기반 중복 검사"란?**
> 암호화된 값을 직접 비교하는 대신, 원본 값의 해시(고정 길이 지문)를 별도 컬럼에 저장하여 DB 레벨에서 빠르게 비교하는 방법. 해시는 단방향이라 원본 복원 불가 → 보안 유지하면서 검색 가능.

---

## Day 6 (Testing + Notifications)

### D-011: Vitest 테스팅 프레임워크
- **날짜**: W2 D6
- **결정**: 단위 테스트 프레임워크로 Vitest 채택.
- **선택한 이유**: Next.js + TypeScript 환경에 최적화. Jest보다 빠르고, ESM 네이티브 지원.
- **포기한 것**: Jest 생태계의 풍부한 플러그인. 하지만 Vitest가 Jest 호환 API를 제공하므로 실질적 손해 적음.
- **재검토 시점**: 해당 없음.

### D-012: 알림 엔진 수동 트리거 (자동 스케줄러 미구현)
- **날짜**: W2 D6
- **결정**: 알림 생성을 "알림 생성" 버튼 클릭 시 수동 실행. cron 기반 자동 스케줄러는 미구현.
- **선택한 이유**: Phase 1에서는 담당자가 하루 1회 수동 실행하면 충분. 자동 스케줄러는 서버 인프라(cron job 또는 serverless scheduler)가 필요해서 배포 복잡도 증가.
- **포기한 것**: 실시간 알림 불가. 담당자가 버튼을 안 누르면 알림이 생성되지 않음.
- **재검토 시점**: Phase 1 후반 — Vercel Cron 또는 외부 스케줄러 도입 시.

---

## Day 7 (AI Chatbot)

### D-013: Playwright E2E 테스트 승인
- **날짜**: W2 D7
- **결정**: Claude Code가 자체 판단으로 추가한 Playwright를 승인하고 유지.
- **선택한 이유**: 챗봇처럼 여러 컴포넌트가 연결되는 기능은 E2E 테스트가 유용. 이미 3개 테스트가 통과한 상태에서 제거하는 것이 낭비.
- **포기한 것**: 의존성 하나 추가 (devDependency). CI/CD에서 브라우저 설치 필요.
- **재검토 시점**: 해당 없음.
- **⚠️ 교훈**: Claude Code가 CLAUDE.md 규칙(새 의존성은 승인 필요)을 어김. 사후 승인한 케이스.

### D-014: ChatMessage 스키마 확장 (필드 추가 방식)
- **날짜**: W2 D7
- **결정**: ChatMessage에 intent, confidence, language, isEscalated, sources(Json) 필드를 개별 컬럼으로 추가. AlertType enum에 CHAT_ESCALATION 추가.
- **선택한 이유**: intent, confidence, isEscalated는 모든 메시지에 일관되게 존재하는 구조화된 데이터. DB 레벨 필터링과 인덱싱 가능. sources만 가변 배열이라 Json 타입.
- **포기한 것**: metadata Json 컬럼 하나로 통합하는 방식 (타입 안전성 없음, 쿼리 불편).
- **재검토 시점**: 해당 없음.

### D-015: 챗봇 이중 모델 전략 (Haiku + Sonnet)
- **날짜**: W2 D7
- **결정**: 인텐트 분류에는 Haiku (저렴/빠름), 응답 생성에는 Sonnet (고품질) 사용.
- **선택한 이유**: 인텐트 분류는 단순 분류 작업이라 저렴한 모델로 충분. 응답 생성은 품질이 중요. 비용 최적화.
- **포기한 것**: 단일 모델 사용 시의 단순한 코드 구조.
- **재검토 시점**: API 비용 분석 후.

---

## 배포 관련 (미확정)

### D-016: Vercel + Supabase (Seoul) 배포 — 미확정
- **날짜**: W1
- **상태**: ❌ 미확정 — Gen에게 질문했으나 응답 없음.
- **내용**: AWS 직접 배포(EC2+RDS, $35-100/월) vs Vercel+Supabase($0-25/월). Supabase는 서울 리전(AWS ap-northeast-2) 지원하여 데이터 국내 보관 요건 충족.
- **결정 필요 시점**: W4 — 보안 감사 전까지 배포 환경 확정 필요.

---

## 랜딩페이지 / 브랜딩

### D-017: 서브도메인 분리 (랜딩 vs 앱), 둘 다 Vercel
- **날짜**: W3
- **결정**: 랜딩페이지와 대시보드 앱을 서브도메인으로 분리. `visacampus.org` = 랜딩, `app.visacampus.org` = 대시보드. 둘 다 Vercel에 배포.
- **선택한 이유**: 배포·장애 완전 독립. 랜딩 문구 수정 시 앱 전체 재빌드 불필요. Vercel은 Next.js 네이티브 지원 + 무료/저비용($0~20/월). AWS는 Phase 1에서 과잉 인프라.
- **포기한 것**: 같은 도메인 경로 방식(`visacampus.org/dashboard`)의 단순함.
- **AWS 마이그레이션 트리거** (하나라도 해당 시 재검토):
  - Vercel 서버리스 함수 타임아웃(10초)에 FIMS 대량 내보내기/임포트가 걸릴 때
  - 동시 접속 사용자 50명 이상으로 Vercel 비용이 AWS보다 비싸질 때
  - 대학 20개 이상 온보딩되어 DB 커넥션 풀 관리가 필요할 때
  - 위탁계약 등에서 "국내 인프라 직접 운영" 조건이 붙을 때
- **재검토 시점**: Phase 2 시작 시 or 위 트리거 발생 시.

### D-018: 브랜드명 VisaCampus + 8주 무료 파일럿
- **날짜**: W3
- **결정**: B2B 브랜드명 VisaCampus (visacampus.org). CTA를 "8주 무료 파일럿 신청"으로 통일.
- **선택한 이유**: 대학(Campus) + 비자(Visa) 조합으로 타겟이 명확. 8주는 온보딩(2~3주) + 실사용(5~6주) + FIMS 보고 시즌 1회 포함 가능.
- **포기한 것**: LocalNomad 브랜드 통합 (B2C와 B2B 분리 결정).
- **재검토 시점**: 파일럿 후 전환율 확인 시 기간 재조정.

### D-019: Supabase를 대시보드 DB로 사용
- **날짜**: 랜딩페이지 배포 후
- **결정**: localnomad-b2b 대시보드와 visacampus-landing 모두 같은 Supabase 프로젝트 사용 (project: bzsxysujtpqipiestcki)
- **선택한 이유**: 관리 포인트 1개, leads → 대시보드 CRM 연동 자연스러움, Supabase Free tier 충분
- **포기한 것**: 랜딩/대시보드 DB 장애 격리 불가 (한쪽 장애 시 양쪽 영향)
- **재검토 시점**: 파일럿 대학 3곳 이상 온보딩 시, 또는 DB 부하 증가 시

### D-020: 테스트 계정 생성
- **날짜**: 첫 배포 후
- **결정**: test@visacampus.org / test1234 (ADMIN, 호서대학교) 테스트 계정 생성
- **비고**: 프로덕션 전 반드시 삭제 또는 비활성화 필요. seed SQL은 `prisma/seed-test-account.sql`
- **재검토 시점**: 파일럿 시작 전 (실제 대학 계정으로 교체)

---

## 기록 규칙

새로운 의사결정 추가 시:
```
### D-XXX: [결정 제목]
- **날짜**: W? D?
- **결정**: [무엇을 결정했는가]
- **선택한 이유**: [왜 이걸 골랐는가]
- **포기한 것**: [이 선택으로 인해 잃는 것]
- **재검토 시점**: [언제 다시 평가해야 하는가]
```
